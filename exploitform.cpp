#include "exploitform.h"
#include "ui_exploitform.h"



ExploitForm::ExploitForm(QWidget *parent) :
    QWidget(parent,Qt::Window | Qt::CustomizeWindowHint | Qt::FramelessWindowHint),
    ui(new Ui::ExploitForm)
{
    RunLine *runline = new RunLine(this);
    runline->resize(458,18);
    runline->move(0,0);
    runline->setFont(QFont("MS Shell Dlg 2",9,QFont::Bold));
    //runline->setAlignment(Qt::Alignment(Qt::AlignmentFlag::AlignHCenter | Qt::AlignmentFlag::AlignVCenter));
    runline->setSpeed(10);
    runline->setStyleSheet("color: #ffd700");
    runline->setString("                                      Rust Legacy Exploit v2.2                                         ");
    current_protect = Ui::RUST_PROTECTS::UNKNOWN;
    unsigned char* ch = license.get_date_time();
    int day = ch[0];
    int month = ch[1];
    int year = *(short*)&ch[2];

    ui->setupUi(this);
    //ui->lineEdit_6->setEnabled(0);
   // ui->lineEdit_5->setEnabled(0);
   // ui->lineEdit_4->setEnabled(0);
    //ui->pushButton_4->setEnabled(0);

    if(license.is_unlim())
        ui->label_4->setText(QString::fromLocal8Bit("Не нужна"));

    else ui->label_4->setText(QString::number(day)+"."+QString::number(month)+"."+QString::number(year));

    if(license.native()){
        ui->label_12->setStyleSheet("color: #00802b");
        ui->label_12->setText(QString::fromLocal8Bit("Есть"));
    }
    else  {
        ui->native_cheat->setEnabled(0);
        ui->label_12->setStyleSheet("color: #1a8cff");
        ui->label_12->setText(QString::fromLocal8Bit("Отсутствует"));
    }

    if(license.hwid_changer_access()){
        ui->label_14->setStyleSheet("color: #00802b");
        ui->label_14->setText(QString::fromLocal8Bit("Есть"));
    }
    else  {
        ui->pushButton_6->setEnabled(0);
        ui->label_14->setStyleSheet("color: #1a8cff");
        ui->label_14->setText(QString::fromLocal8Bit("Отсутствует"));
    }
    if(!license.steam_id_access()){
        ui->lineEdit_7->setEnabled(0);
        ui->pushButton_9->setEnabled(0);
    }
    if(license.screen_hook_access()){
        ui->label_16->setStyleSheet("color: #00802b");
        ui->label_16->setText(QString::fromLocal8Bit("Есть"));
    }
    else  {
        ui->pushButton_4->setEnabled(0);
        ui->lineEdit_4->setEnabled(0);
        ui->lineEdit_5->setEnabled(0);
        ui->lineEdit_6->setEnabled(0);
        ui->label_16->setStyleSheet("color: #1a8cff");
        ui->label_16->setText(QString::fromLocal8Bit("Отсутствует"));
    }
}
void ExploitForm::Initialize()
{
    if(!license.is_licensed() || license.banned()){
        QMetaObject::invokeMethod(this, "close", Qt::QueuedConnection);
        return;
    }
    m_hProcessHelper = LoadLibraryW(L"MInject.dll");
    if(!mono_helper.Initialize(m_hProcessHelper))
    {
        error.setText(QString::fromLocal8Bit("Can not to find the MInject.dll file"));
        error.exec();
        QMetaObject::invokeMethod(this, "close", Qt::QueuedConnection);
    }

}
ExploitForm::~ExploitForm()
{

    delete ui;
}

void ExploitForm::on_pushButton_2_clicked()
{
    this->showMinimized();
}

void ExploitForm::on_pushButton_clicked()
{
    qApp->exit();
}

void ExploitForm::on_pushButton_3_clicked()
{
    QString fileName = QFileDialog::getOpenFileName(this, ("Open File"),
                                                     "",
                                                     ("Assembly (*.dll)"));
    ui->textEdit->setText(fileName);
}

void ExploitForm::on_pushButton_5_clicked()
{
        if(pID != GetProcessID((wchar_t*)L"rust.exe"))
        {
            ui->listWidget->clear();
            mono_helper.get_images()->clear();
        }
        pID = GetProcessID((wchar_t*)L"rust.exe");
        switch (current_protect) {
            case Ui::RUST_PROTECTS::RUST_PROTECT:
            {
                bool result = false;
                if(ui->native_cheat->isChecked() && license.native())
                {                 
                    result = rust_protect_bypass(&mono_helper,nullptr,nullptr,nullptr,nullptr,true);

                }
                else {
                        ZeroMemory(this->name_space,255);
                        ZeroMemory(this->class_name,255);
                        ZeroMemory(this->method_name,255);

                        strcpy(this->name_space,(char*)ui->lineEdit->text().toLatin1().data());
                        strcpy(this->class_name,(char*)ui->lineEdit_2->text().toLatin1().data());
                        strcpy(this->method_name,(char*)ui->lineEdit_3->text().toLatin1().data());

                        if(strlen(this->method_name) != 0 &&
                           strlen(this->class_name) != 0  &&
                           strlen(this->name_space) != 0  &&
                           strlen(ui->textEdit->toPlainText().toLocal8Bit().data()) != 0)
                        {

                            result = rust_protect_bypass(&mono_helper,ui->textEdit->toPlainText().toLocal8Bit().data(),this->name_space,this->class_name,this->method_name,false);
                        }
                }
                if(!result){
                    error.setText(QString::fromLocal8Bit("Error of injection!"));
                }
                 else {
                     error.setText(QString::fromLocal8Bit("Success!"));
                }
                error.exec();
                break;
            }
            case Ui::RUST_PROTECTS::RUST_FSHIELD:
            {
            bool result = false;
            if(ui->native_cheat->isChecked() && license.native())
            {
                result = FShieldBypass(&mono_helper,nullptr,nullptr,nullptr,nullptr,true);

            }
            else {
                    ZeroMemory(this->name_space,255);
                    ZeroMemory(this->class_name,255);
                    ZeroMemory(this->method_name,255);

                    strcpy(this->name_space,(char*)ui->lineEdit->text().toLatin1().data());
                    strcpy(this->class_name,(char*)ui->lineEdit_2->text().toLatin1().data());
                    strcpy(this->method_name,(char*)ui->lineEdit_3->text().toLatin1().data());

                    if(strlen(this->method_name) != 0 &&
                       strlen(this->class_name) != 0  &&
                       strlen(this->name_space) != 0  &&
                       strlen(ui->textEdit->toPlainText().toLocal8Bit().data()) != 0)
                    {

                        result = FShieldBypass(&mono_helper,ui->textEdit->toPlainText().toLocal8Bit().data(),this->name_space,this->class_name,this->method_name,false);
                    }
            }
            if(!result){
                error.setText(QString::fromLocal8Bit("Error of injection!"));
            }
             else {
                 error.setText(QString::fromLocal8Bit("Success!"));
            }
            error.exec();
                break;
            }
            case Ui::RUST_PROTECTS::RUST_BOOSTER:
            {
            bool result = false;
            if(ui->native_cheat->isChecked() && license.native())
            {
                result = rust_buster_bypass(&mono_helper,nullptr,nullptr,nullptr,nullptr,true);

            }
            else {
                    ZeroMemory(this->name_space,255);
                    ZeroMemory(this->class_name,255);
                    ZeroMemory(this->method_name,255);

                    strcpy(this->name_space,(char*)ui->lineEdit->text().toLatin1().data());
                    strcpy(this->class_name,(char*)ui->lineEdit_2->text().toLatin1().data());
                    strcpy(this->method_name,(char*)ui->lineEdit_3->text().toLatin1().data());

                    if(strlen(this->method_name) != 0 &&
                       strlen(this->class_name) != 0  &&
                       strlen(this->name_space) != 0  &&
                       strlen(ui->textEdit->toPlainText().toLocal8Bit().data()) != 0)
                    {

                        result = rust_buster_bypass(&mono_helper,ui->textEdit->toPlainText().toLocal8Bit().data(),this->name_space,this->class_name,this->method_name,false);
                    }
            }
            if(!result){
                error.setText(QString::fromLocal8Bit("Error of injection!"));
            }
             else {
                 error.setText(QString::fromLocal8Bit("Success!"));
            }
            error.exec();

                break;
            }
            default:
            {
                error.setText(QString::fromLocal8Bit("Selected protection does not work"));
                error.exec();
                break;
            }
        }

        ui->listWidget->clear();
        unordered_map<std::string,void*>:: iterator itr;
        for (itr = this->mono_helper.get_images()->begin(); itr != this->mono_helper.get_images()->end(); itr++)
        {
            ui->listWidget->addItem(itr->first.data());
        }

}


void ExploitForm::on_radioButton_clicked()
{
    current_protect = Ui::RUST_PROTECTS::RUST_PROTECT;
}

void ExploitForm::on_radioButton_2_clicked()
{
    current_protect = Ui::RUST_PROTECTS::RUST_FSHIELD;
}

void ExploitForm::on_radioButton_3_clicked()
{
    current_protect = Ui::RUST_PROTECTS::RUST_BOOSTER;
}

void ExploitForm::on_pushButton_7_clicked()
{
    ShellExecute( NULL,L"open",L"https://vk.com/sofckbad",NULL,NULL,SW_SHOW);
}

void ExploitForm::on_pushButton_6_clicked()
{
    if(license.is_licensed() && license.hwid_changer_access()){
        ActivateHWIDChanger(&this->mono_helper);
    }
}


void ExploitForm::on_pushButton_4_clicked()
{    

    if(!license.screen_hook_access() || !license.is_licensed())
    {
            return;
    }

    if(pID != GetProcessID((wchar_t*)L"rust.exe"))
    {
        ui->listWidget->clear();
        mono_helper.get_images()->clear();
    }
    pID = GetProcessID((wchar_t*)L"rust.exe");
   QMessageBox box;
   HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,0,GetProcessID((wchar_t*)L"rust.exe"));



   if(!hProcess || !mono_helper.ConnectToProcess()){
       box.setText("Can not to get access to the process");
       box.exec();
        return;
    }

    mono_helper.MonoThreadAttach(mono_helper.MonoGetRootDomain());
    mono_helper.MonoSecuritySetMode(0);


    void    *called_method = mono_helper.MonoGetMethodFromName(mono_helper.MonoClassFromName(mono_helper.MonoImageLoaded((char*)"RustProtect.Core"),
                                                               (char*)"RustProtect",
                                                               (char*)"Snapshot"),
                                                               (char*)"CaptureSnapshot",0),

            *calling_method = mono_helper.MonoJitGetCodeStart(mono_helper.MonoImageLoaded((char*)"RustProtect.Core"),
                                                                   (char*)"RustProtect",
                                                                   (char*)"Protection",
                                                                   (char*)"DoNetworkMessageData",2,0),
            *called_method_jit = mono_helper.MonoJitGetCodeStart(mono_helper.MonoImageLoaded((char*)"RustProtect.Core"),
                                                                   (char*)"RustProtect",
                                                                   (char*)"Snapshot",
                                                                   (char*)"CaptureSnapshot",0,0);



    int calling_method_size = mono_helper.GetCodeSize((char*)"RustProtect.Core",
                                                      (char*)"RustProtect",
                                                      (char*)"Protection",
                                                (char*)"DoNetworkMessageData",2,0);
    char* selected_image_name = nullptr;
    void* selected_image_method = nullptr;

    if(ui->listWidget->currentItem()){
        selected_image_name = ui->listWidget->currentItem()->text().toLocal8Bit().data();
        std::unordered_map<std::string,void*>::const_iterator got = mono_helper.get_images()->find(selected_image_name);
        if(got != mono_helper.get_images()->end()){
            selected_image_method = mono_helper.MonoJitGetCodeStart(got->second,
                                                                  ui->lineEdit_4->text().toLocal8Bit().data(),
                                                                  ui->lineEdit_5->text().toLocal8Bit().data(),
                                                                  ui->lineEdit_6->text().toLocal8Bit().data(),0,0);

        }
    }

    if(selected_image_method == nullptr ){
        box.setText("Can not find hooking method");
        box.exec();
        CloseHandle(hProcess);
         return ;
    }
   if(called_method == nullptr || calling_method == nullptr ||
       calling_method_size ==0 || called_method_jit == nullptr){
       box.setText("Can not find original get screen method");
       box.exec();
       CloseHandle(hProcess);
        return ;
    }

    void* buffer = malloc(calling_method_size);
    ZeroMemory(buffer,calling_method_size);
    ReadProcessMemory(hProcess,calling_method,buffer,calling_method_size,NULL);

    for(int i = 0;i<calling_method_size;i++)
    {

        if(((unsigned char*)buffer)[i] == rCall)
        {
            unsigned long relative_address = *(unsigned long*)((unsigned long)buffer+i+1);
            unsigned long absolute_address = ORIGINAL_ADDRESS(relative_address,(unsigned long)calling_method+i);
            unsigned long t_address = 0;

            if(absolute_address == (unsigned long)called_method_jit)
            {
                 unsigned long hook_func_relative = (unsigned long)selected_image_method - ((unsigned long)calling_method+i) - 5;
                 WriteProcessMemory(hProcess,(void*)((unsigned long)calling_method+i+1),&hook_func_relative,sizeof(void*),NULL);
                 box.setText("Success!");
                 box.exec();
                 continue;
            }

            DWORD oldProtect;
            VirtualProtectEx(hProcess,(void*)absolute_address,5,PAGE_EXECUTE_READWRITE,&oldProtect);
            ReadProcessMemory(hProcess,(void*)(absolute_address+1),&t_address,4,NULL);

            if(t_address == (unsigned long)called_method)
            {
                unsigned long hook_func_relative = (unsigned long)selected_image_method - ((unsigned long)calling_method+i) - 5;
                WriteProcessMemory(hProcess,(void*)((unsigned long)calling_method+i+1),&hook_func_relative,sizeof(void*),NULL);
                box.setText("Success!");
                box.exec();
            }
        }
    }

    CloseHandle(hProcess);
    free(buffer);
}


void ExploitForm::on_pushButton_8_clicked()
{
   char* info = "";
    ofstream of;
    of.open("info.txt");
    of.write(info,strlen(info));
    of.close();
    ShellExecute( NULL,L"open",L"info.txt",NULL,NULL,SW_SHOW);
}

void ExploitForm::on_pushButton_9_clicked()
{
    if(!license.is_licensed() || !license.steam_id_access())
    {
        return;
    }
    QMessageBox box;
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS,0,GetProcessID((wchar_t*)L"rust.exe"));
    if(!hProcess || !mono_helper.ConnectToProcess())
    {
        box.setText("Can not to get access to process!");
        box.exec();
        return;
    }

    void* Steam_GetSteamID = mono_helper.GetExportProcedure((char*)"librust.dll",(char*)"Steam_GetSteamID");

    if(Steam_GetSteamID == nullptr)
    {
        box.setText("Can not find needed function!");
        box.exec();
        CloseHandle(hProcess);
        return;
    }

    unsigned long long SteamID =ui->lineEdit_7->text().toLongLong();
    unsigned int UPPERBYTES = SteamID >> 32;
    unsigned int LOWBYTES = SteamID & 0xFFFFFFFF;

    asmjit::JitRuntime runtime;
    asmjit::X86Assembler assembler(&runtime, asmjit::kArchHost);

    assembler.mov(asmjit::host::edx,UPPERBYTES);
    assembler.mov(asmjit::host::eax,LOWBYTES);
    assembler.ret();

    void* steam_id_epilogue = assembler.make();
    size_t code_size = assembler.getCodeSize();

    WriteProcessMemory(hProcess,Steam_GetSteamID,steam_id_epiloge,code_size,0);

    box.setText("Sucess!");
    box.exec();

    CloseHandle(hProcess);
    runtime.release(steam_id_epilogue);
}

void ExploitForm::on_pushButton_10_clicked()
{
    QMessageBox box;
    if( remove( "save_hwid.bin" ) != 0 ){
        box.setText("Failed!");

    }
    else{
        box.setText("Succes!");
    }
    box.exec();
}
